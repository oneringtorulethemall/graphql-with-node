# import UserOrderByInput from './generated/prisma.graphql'
# import PostOrderByInput from './generated/prisma.graphql'
# import CommentOrderByInput from './generated/prisma.graphql'

## alternate syntax
## import UserOrderByInput, PostOrderByInput, CommentOrderByInput from '.file'



type Query {
    me: User!
    post( id: ID!) : Post!
    posts( query: String, first: Int, skip: Int, after: String, orderBy: PostOrderByInput) : [Post!]!
    myposts ( query: String, first: Int, skip: Int, after: String, orderBy: PostOrderByInput) : [Post!]!
    users (query: String, first: Int, skip: Int, after: String, orderBy: UserOrderByInput): [User!]!
    user ( id: ID!) : User!
    comments (query: String, first: Int, skip: Int, after: String, orderBy: CommentOrderByInput) : [Comment!]!
    comment ( id: ID!) : Comment
    greeting(name: String, position: String): String!
    add (numbers: [Float!]! ) : Float!
    grades: [Int!]!

}

type Mutation {

    login(data: LoginUserInput!) : AuthPayload!
    createUser(data: CreateUserInput!) : AuthPayload!
    updateSpecificUser(id: ID!, data: UpdateUserInput!) : User!
    updateUser(data: UpdateUserInput!) : User!
    deleteUser(id: ID!) : User!

    createPost(data: CreatePostInput!) : Post!
    deletePost(id: ID!) : Post!
    updatePost(id: ID!, data: UpdatePostInput! ) : Post!

    createComment(data: CreateCommentInput) : Comment!
    deleteComment(id: ID!) : Comment!
    updateComment(id: ID!, data: UpdateCommentInput) : Comment!

}

type Subscription {
    count : Int!
    comment  (postID: ID!) : CommentSubscriptionPayload!
    post : PostSubscriptionPayload!
    mypost : PostSubscriptionPayload!
    user : UserSubscriptionPayLoad!

}

type AuthPayload {
    token: String!
    user: User!
}

input LoginUserInput {
    email: String!
    password: String!
}

input CreateUserInput {
    name: String!,
    email: String!,
    password: String!
}

input UpdateUserInput {
    name: String,
    email: String,
    password: String
}


# what should happen when a record is deleted?
# SET_NULL  (default)
# CASCADE   (delete will update/delete everything in relationship)


type User {
    id: ID!   # @unique
    name: String!
    email: String  
    password: String
    posts: [Post!]! 
    comments: [Comment!]! 
    createdAt: String!
    updatedAt: String!
}

type Post {
    id: ID!  
    title: String!
    body: String!
    published: Boolean!
    author: User! 
    comments: [Comment!]! 
    createdAt: String!
    updatedAt: String!
}

input CreatePostInput {
    title: String!
    body: String!
    published: Boolean!
    # author: ID!
}

input UpdatePostInput {
    title: String
    body: String
    published: Boolean
}

type Comment {
id: ID!  
text: String!
author: User! 
post: Post! 
createdAt: String!
updatedAt: String!
}

input CreateCommentInput {
    text: String!
    # author: ID! - this will be auto assigned based on logged in user
    # need a method for Administrator to call this
    # and specify the author id to use...
    post: ID!
}


input UpdateCommentInput {
    text: String!
}

enum MutationType {
    CREATED
    UPDATED
    DELETED
}


type PostSubscriptionPayload {
   mutation: MutationType!
   # data: Post!
   node: Post!

}

type UserSubscriptionPayLoad {
    mutation: MutationType!
    node: User
}

type CommentSubscriptionPayload {
    mutation: MutationType!
    # data: Comment!
    # node is what graphql returns as the data element
    # for subscription.
    node: Comment!
}
